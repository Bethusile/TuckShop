// server/src/services/categoryService.ts
import db from '../knex';

// --- Types ---
interface Category {
    categoryid: number;
    name: string;
}

// --- Service Logic ---

// 1. READ ALL Categories
export const fetchAllCategories = async (): Promise<Category[]> => {
    return db('category').select('*').orderBy('name', 'asc');
};

// 2. READ ONE Category
export const fetchCategoryById = async (categoryid: number): Promise<Category | undefined> => {
    return db('category').select('*').where({ categoryid }).first();
};

// 3. CREATE Category
export const createCategory = async (name: string): Promise<Category> => {
    // Note: The categoryid is auto-generated by PostgreSQL SERIAL
    const [newCategory] = await db('category')
        .insert({ name })
        .returning('*');
    
    // Knex's returning behavior can sometimes return an array even for a single insert
    return newCategory;
};

// 4. UPDATE Category
export const updateCategory = async (categoryid: number, name: string): Promise<number> => {
    // Returns the number of rows affected (0 or 1)
    return db('category')
        .where({ categoryid })
        .update({ name });
};

// 5. DELETE Category
export const deleteCategory = async (categoryid: number): Promise<number> => {
    // First, check if there are any products associated with this category
    const productsCount = await db('product')
        .where({ categoryid })
        .count('itemid as count')
        .first();
    
    const count = productsCount ? Number(productsCount.count) : 0;
    
    if (count > 0) {
        throw new Error(`Cannot delete category. ${count} product(s) are still associated with this category.`);
    }
    
    // If no products are associated, proceed with deletion
    return db('category').where({ categoryid }).del();
};